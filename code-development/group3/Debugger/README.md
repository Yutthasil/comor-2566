# Debugger

debugger คือเครื่องมือที่ทำให้ programmer สามารถตรวจสอบการทำงานทีละลำดับของโค้ด, วางจุด breakpoints ภายในโค้ด, ตรวจดู memory, เปลี่ยนค่าและตรวจสอบตัวแปร, และอื่นๆ โดยหนึ่งใน serial debuggers ที่สามารถใช้งานได้คือ gnu debugger (GDB)

## GDB

GDB ย่อมาจาก "Gnu DeBugger" เป็นแพ็คเกจดีบั๊กsource-levelที่สามารถดูสิ่งที่เกิดขึ้นภายในโปรแกรม โดยผู้ใช้สามารถให้กลุ่มคำสั่งเพื่อที่จะตรวจสอบโค้ด, วางจุด breakpoints, ตรวจสอบ/เปลี่ยนแปลงตัวแปร และอื่นๆ, มีหลายgraphical front ends สำหรับ GDB ที่แปลงคำสั่ง GUI เป็นคำสั่งข้อความ อย่างเช่น Eclipse, และคล้ายกับเครื่องมือ Linux ส่วนใหญ่, GDB ก็ใช้ระบบ command line, ซึ่งทำให้มีการใช้งานที่ค่อนข้างยากเช่นกัน
<br>GDB สามารถตั้งค่าให้ทำงานบนเครื่องโฮสหลัก ขณะที่ทำการ debug โค้ดบนอี่กเครื่องหนึ่งได้ โดยทั้งสองเครื่องสามารถเชื่อมต่อกันผ่านพอร์ตซีเรียลหรือเน็ตเวิร์ค หรือ in-circuit emulator (ICE) ได้ 

Gdb คือ debugger สำหรับภาษา C และC++ ที่ทำให้สามารถรันโปรแกรมได้จนถึงจุดหนึ่ง ทำการหยุดรันแล้วปริ้นค่า ตัวแปรที่กำหนด, หรือทำคำสั่งไปทีละบรรทัด และปริ้นค่าของแต่ละตัวแปรหลังจากที่ทำคำสั่งบรรทัดนั้น โดยการใช้ command line interface

การจะ debug โค้ดนั้น โค้ดจะต้องถูกคอมไพล์พร้อมข้อมูลการ debug ส่วนใหญ่นั้นสามารถทำได้โดยการเพิ่มargument "-g" เข้าไปในลิสต์ของคอมไพเลอร์เมื่อทำการคอมไพล์

แต่การ debug แอปพลิเคชันพร้อมกันบน commodity cluster  ทำให้เกิดความซับซ้อนหลายอย่าง โดยวิธีที่ง่ายและตรงไปตรงมาในการ debug แอปพลิเคชันพร้อมกันบน commodity cluster คือการใช้ serial debugger สำหรับแต่ละกระบวนการ

## Compiling

การจะ debug โปรแกรมด้วยGDBนั้น, โปรแกรมจะต้องถูกคอมไพล์ด้วยตัวดัชนี “-g” ถ้าหากโปรแกรมอยู่ใน source file ชื่อ *memsim.c* และอยากใส่โค้ดที่ทำงานได้บนไฟล์ *memsim*, จะจำเป็นต้องcompile ด้วยคำสั่งต่อไปนี้:
<br>

```bash
gcc -g -o memsim memsim.c
```

## Invoking and Quitting GDB

สามารถพิมพ์ *gdb* ลงบน unix prompt เพื่อเริ่ม GDB ได้. โดยGDB จะให้ prompt *(gdb)* โดยจะสามารถรันโปรแกรม, ดูตัวแปร, ใช้งานคำสั่ง, หรือเริ่ม GDB และให้ชื่อโปรแกรมที่ต้องการจะ debug ด้วย
<br>

```bash
gdb executable
```

หรือจะพิมพ์ *quit* หรือ *q* ที่ *(gdb)* prompt เพื่อออกจากโปรแกรมก็ได้

## Commands

### **help**
<br>

-GDB จะมีเอกสารออนไลน์อยู่. เพียงพิมพ์ *help* ก็จะแสดงหัวข้อต่างๆ จากนั้นพิมพ์ *help topic* เพื่อรับข้อมูลเกี่ยวกับหัวข้อนั้นๆ หรือพิมพ์*help command* เพื่อรับข้อมูลเกี่ยวกับคำสั่งต่างๆ

### **file**
<br>

-*file executable* บ่งบอกโปรแกรมที่คุณต้องการจะ debug.

### **run**
<br>

-*run* จะเริ่มการทำงานของโปรแกรมด้วย GDB โดยจะเป็นโปรแกรมที่เคยเลือกไว้ผ่านคำสั่ง *file*, หรือบน Unix command line ตอนที่เริ่มการทำงานของGDB, คุณสามารถให้ command line arguments ให้กับโปรแกรมของคุณบน GDB command เหมือนกับที่ทำบน Unix command line, แต่จะเป็นการพิมพ์ *run* แทนชื่อโปรแกรม:
<br>

```bash
run 2048 24 4
```

หรือใช้ทำการเปลี่ยนเส้นทางของ input/output ด้วย: *run > outfile.txt*

### **break**
<br>

-breakpoint คือตำแหน่งบนโปรแกรมที่คุณต้องการให้หยุดการทำงานชั่วคราวเพื่อเช็คค่าของตัวแปร, หาจุดที่เป็นปัญหาของโปรแกรม, และอื่นๆ โดยกำหนดจุด breakpoint ด้วยคำสั่ง *break* 

*break function* จะกำหนด breakpoint ที่จุดเริ่มต้นของ *function* ถ้าหากโค้ดอยู่ในหลายๆไฟล์, อาจจะต้องกำหนดชื่อไฟล์ด้วย *filename:function*

*break linenumber* หรือ *break filename:linenumber* จะกำหนด breakpoint ที่บรรทัดที่กำหนดใน source file โดยจะหยุดการทำงานก่อนที่บรรทัดนั้นจะทำงาน

### **delete**
<br>

-*delete* จะลบ breakpoints ทั้งหมดที่ได้กำหนดไว้

*delete number* จะลบ breakpoints ตามค่า *number* ที่กำหนด โดยสามารถดูค่าของ breakpoint ได้โดยใช้ *info breakpoints*

### **clear**
<br>

-*clear function* จะลบ breakpoints ที่ได้กำหนดไว้ในfunctionนั้นๆ และใช้ *linenumber, filename:function, และ filename:linenumber*  คล้ายๆกันกับคำสั่ง *break*

### **continue**
<br>

-*continue* จะสั่งให้โปรแกรมทำงานต่ออีกครั้งหลังจากที่หยุดบน breakpoint.

### **step**
<br>

-*step* จะทำการทำงานคำสั่งบนบรรทัดปัจจุบัน, แล้วหยุดทำงานอีกครั้งก่อนทำงานบรรทัดถัดไป 

### **next**
<br>

-*next* จะทำงานคล้ายๆกับ *step*, แต่ถ้าบรรทัดที่กำลังจะทำงานนั้นเป็นคำสั่งเรียกใช้ฟังก์ชัน จะทำการทำงานทั้งฟังก์ชันที่เรียกนั้นก่อนที่จะหยุดการทำงานอีกครั้ง, ขณะที่ *step* จะหยุดการทำงานที่บรรทัดแรกของฟังก์ชันที่ถูกเรียกมา

### **until**
<br>

-*until* จะเหมือนกับ *next*, แต่ว่าหากอยู่ที่ท้ายloop *until* จะทำงานต่อไปจนกว่าจะออกจากloop ขณะที่ *next* จะพากลับไปยังจุดเริ่มของ loop จึงเหมาะสำหรับดูผลที่จะเกิดขึ้นหลังจากการloop แต่ไม่ต้องการจะข้ามทุกการทำซ้ำ

### **list**
<br>

-*list linenumber* จะปริ้นบรรทัดบางส่วนจาก source code ตรงที่ *linenumber* หากมีการกำหนด argument *function* จะทำให้มีการปริ้นบรรทัดตั้งแต่ต้นฟังก์ชั่น การใช้ *list* โดยไม่มี arguments จะทำการปริ้นบรรทัดถัดไปจากบรรทัดล่าสุดที่ปริ้นด้วยคำสั่ง *list* 

### **print**
<br>

-*print expression* จะทำการปริ้นค่าของ expression ที่สามารถเป็นได้ตั้งแต่ชื่อตัวแปร, ไปจนถึงค่าใน array ตามจำนวนค่าที่กำหนดโดยเรียกว่า *list* ด้วยคำสั่ง
<br>

```bash
print list[0]@amount
```

# Reference

-[GNU Debugger](https://www.sciencedirect.com/topics/computer-science/gnu-debugger)

-[GNU Tutorial](https://web.eecs.umich.edu/~sugih/pointers/summary.html)

