<a id="BootProcess"></a>
# :round_pushpin: Boot Process
### Overview :
กระบวนการบูตของLinuxเป็นส่วนสำคัญของการทำงาน เนื่องจากเป็นขั้นตอนเริ่มต้นในการเริ่มระบบปฏิบัติการ ทุกครั้งที่คุณกดปุ่มเปิดเครื่อง ระบบของคุณจะใช้เวลาสักครู่ในการเตรียมความพร้อมและแสดงหน้าเข้าสู่ระบบ คุณอาจสงสัยว่าเบื้องหลังมีการดำเนินการอะไรบ้าง บทความนี้จะอธิบายว่าLinuxจัดการกระบวนการบูตระบบอย่างไร 

### Introduction :
 Booting คือกระบวนการที่นำระบบจากสถานะปิดไปสู่ระบบปฏิบัติการที่กำลังทำงาน โดยขั้นตอนทั้งหมดแบ่งออกเป็น 4 ขั้นตอนหลัก มีดังนี้:
 
  <img src="https://github.com/MaledKhaoSan/Project-Comor/blob/main/assets/boot%20process.png?raw=true" >

- Firmware stage
 
- Bootloader stage

- Kernel stage
  
- Init stage
  
  <img src="https://www.baeldung.com/wp-content/uploads/sites/2/2022/10/boot-process-662x1024.png" >
<br><br>
<a id="Firmwarestage"></a>
# :round_pushpin: Firmware stage
คือขั้นตอนแรกที่เกิดขึ้นหลังจากคอมพิวเตอร์เปิดเครื่อง เป็นซอฟต์แวร์ที่ฝังอยู่บนชิปฮาร์ดแวร์ ทำหน้าที่ควบคุมการทำงานพื้นฐานของอุปกรณ์ เฟิร์มแวร์จะทำงานก่อนระบบปฏิบัติการ Linux โหลดขึ้นมา ทำหน้าที่เตรียมอุปกรณ์ให้พร้อมใช้งาน เช่น การตรวจสอบฮาร์ดแวร์ การตั้งค่าคอนฟิกเบื้องต้น และการโหลดบูตโลเดอร์
<br><br>
### แบ่งออกเป็น 2 ประเภทหลักๆ ดังนี้:

1. เฟิร์มแวร์ BIOS/UEFI: เฟิร์มแวร์ส่วนใหญ่ของคอมพิวเตอร์เรียกว่า Basic Input/Output System (BIOS)เป็นเฟิร์มแวร์ที่ควบคุมการทำงานพื้นฐานของเมนบอร์ด เช่น การตรวจสอบฮาร์ดแวร์ การตั้งค่าวันที่และเวลา การบูตระบบปฏิบัติการ

2. เฟิร์มแวร์อุปกรณ์: เป็นเฟิร์มแวร์ที่ควบคุมการทำงานของอุปกรณ์เฉพาะ เช่น การ์ดจอ การ์ดเสียง ไดรฟ์ Wi-Fi
<br><br>
### มีหน้าที่หลัก 3 อย่าง ได้แก่:

1.ตรวจสอบระบบด้วย Power-On Self Test (POST): เพื่อให้แน่ใจว่าฮาร์ดแวร์ทำงานอย่างถูกต้อง

2.ระบุฮาร์ดแวร์ที่มีอยู่: เช่น หน่วยความจำ, ดิสก์ และอุปกรณ์ USB 

3.ค้นหาไดร์ฟบูตที่เหมาะสมจากอุปกรณ์จัดเก็บที่มีอยู่และโหลด Master Boot Record (MBR)

---
### รายละเอียดของแต่ละขั้นตอน:

1. POST (Power-On Self Test):

- เฟิร์มแวร์จะตรวจสอบว่า CPU ทำงานปกติหรือไม่

- เฟิร์มแวร์จะตรวจสอบว่า RAM ทำงานปกติหรือไม่

- เฟิร์มแวร์จะตรวจสอบว่าอุปกรณ์ต่อพ่วง เช่น ฮาร์ดดิสก์ การ์ดจอ ทำงานปกติหรือไม่

2. Initialization:

- เฟิร์มแวร์จะตั้งค่าวันที่และเวลา

- เฟิร์มแวร์จะตั้งค่าคอนฟิกอุปกรณ์ต่อพ่วง

- เฟิร์มแวร์จะตั้งค่าคอนฟิก BIOS/UEFI

3. Bootloader:

- เฟิร์มแวร์จะค้นหาบูตโลเดอร์จากอุปกรณ์ต่อพ่วง เช่น ฮาร์ดดิสก์ หรือ USB drive

- เฟิร์มแวร์จะโหลดบูตโลเดอร์เข้าสู่หน่วยความจำ

- บูตโลเดอร์จะทำหน้าที่โหลดระบบปฏิบัติการ Linux

4. Operating System:

- บูตโลเดอร์จะโหลดระบบปฏิบัติการ Linux เข้าสู่หน่วยความจำ

- ระบบปฏิบัติการ Linux จะเริ่มทำงาน

> [!CAUTION]
> การตั้งค่าคอนฟิก BIOS/UEFI อาจทำให้ระบบทำงานไม่เสถียร

<a id="Bootloaderstage"></a>
# :round_pushpin: Bootloader stage
 เป็นขั้นตอนสำคัญที่เตรียมฮาร์ดแวร์ ค้นหา และโหลดระบบปฏิบัติการ Bootloader ยอดนิยม ได้แก่ GRUB หน้าที่หลักของ bootloader ขั้นตอนแรก คือ โหลด bootloader ขั้นตอนที่สอง เข้ามาทำงานต่อ ,bootloader ขั้นตอนที่สองจะทำหน้าที่โหลดเคอร์เนลของ Linux เข้าไปในหน่วยความจำ และรัน (execute) เคอร์เนลนั้น
 
 ### ทำหน้าที่หลัก ดังนี้

1. เตรียมการฮาร์ดแวร์:

- ตรวจสอบและตั้งค่าหน่วยความจำ (RAM)

- เริ่มต้นระบบ I/O เช่น คีย์บอร์ด จอภาพ

- โหลดอุปกรณ์ต่อพ่วงที่จำเป็น

2. ค้นหาและโหลดระบบปฏิบัติการ:

- ค้นหาพาร์ทิชันระบบปฏิบัติการ

- โหลด kernel ของ Linux เข้าสู่หน่วยความจำ

- ส่งต่อการควบคุมให้กับ kernel

3. แสดงเมนูตัวเลือก:

- เสนอตัวเลือกการบูทระบบปฏิบัติการ

- อนุญาตให้ผู้ใช้เลือก kernel เวอร์ชัน

- ตั้งค่าพารามิเตอร์การบูท
---
### Bootloader ยอดนิยมที่ใช้ใน Linux:

- GRUB/GRUB2 (Grand Unified Bootloader): ตัวเลือกมาตรฐาน เป็นBootloaderที่ได้รับความนิยมมากที่สุด รองรับระบบ UEFI และ BIOS

- Bootloader อื่นๆ:
   - SILO (Spark Improved bootLOader): รองรับ Linux บนฮาร์ดแวร์ Sun SPARK
   - YABOOT (Yet Another BOOTloader): รองรับฮาร์ดแวร์ PowerPC

Boot ผ่านเครือข่าย:

- PXE (Preboot Execution Environment): สำหรับฮาร์ดแวร์ที่รองรับ TFTP ใช้ในการดาวน์โหลด bootloader พิเศษจากเซิร์ฟเวอร์

---
### ประเภทของ Bootloader:

- MBR (Master Boot Record): พบในระบบ BIOS เก็บข้อมูลเกี่ยวกับพาร์ทิชันและ bootloader
- GPT (GUID Partition Table): พบในระบบ UEFI เก็บข้อมูลเกี่ยวกับพาร์ทิชันและ bootloader
---
### การเรียกใช้งาน:

Bootloader stage จะถูกเรียกใช้งานโดยอัตโนมัติเมื่อเปิดเครื่องคอมพิวเตอร์ กระบวนการทำงานมีดังนี้:

- POST (Power-On Self Test): เมื่อเปิดเครื่อง คอมพิวเตอร์จะทำการ POST เพื่อตรวจสอบฮาร์ดแวร์
- BIOS/UEFI: BIOS หรือ UEFI จะค้นหาอุปกรณ์บูทที่มี bootloader
- Bootloader: Bootloader จะโหลดตัวเองเข้าสู่หน่วยความจำ
- ค้นหาพาร์ทิชัน: Bootloader จะค้นหาพาร์ทิชันระบบปฏิบัติการ
- โหลด kernel: Bootloader จะโหลด kernel ของ Linux เข้าสู่หน่วยความจำ
- ส่งต่อการควบคุม: Bootloader จะส่งต่อการควบคุมให้กับ kernel
- Kernel: Kernel จะเริ่มต้นระบบปฏิบัติการ
  
### Command ที่เกี่ยวข้องกับ Bootloader stage ใน Linux

Command : `GRUB`

- `grub-install` : ติดตั้ง GRUB bootloader
  
   - `--target=DEVICE` : ระบุอุปกรณ์เป้าหมาย เช่น `--target=/dev/sda`
     
   - `--efi-directory=DIRECTORY`: ระบุไดเร็กทอรี EFI เช่น `--efi-directory=/boot/efi`
     
- `grub-mkconfig` : สร้างไฟล์การกำหนดค่า GRUB
  
   - `--output=FILE` : ระบุไฟล์เอาต์พุต เช่น `--output=/boot/grub/grub.cfg`
     
   - `--theme=THEME` : ระบุธีม เช่น `--theme=classic`
     
- `grub-reboot` : รีบูทเครื่องเพื่อใช้การกำหนดค่า GRUB ใหม่

> [!CAUTION]
> ผู้ใช้ควรสำรองข้อมูลไฟล์การกำหนดค่า bootloader ก่อนทำการแก้ไข
> 
> การแก้ไขไฟล์การกำหนดค่า bootloader ผิดพลาด อาจทำให้ระบบปฏิบัติการไม่สามารถบูทได้

<a id="Kernelstage"></a>
# :round_pushpin: Kernel stage
Kernel stage ป็นขั้นตอนสำคัญอันดับแรกของกระบวนการบูตระบบปฏิบัติการ Linux มันเกิดขึ้นหลังจากการทดสอบตัวเองของอุปกรณ์ (POST - Power-On Self Test)เสร็จสิ้น และก่อนที่init systemจะเริ่มทำงาน หน้าที่หลักของขั้นตอนนี้คือเตรียมระบบให้พร้อมใช้งานโปรแกรมอื่นๆ

### หน้าที่หลักของ Kernel stage มีดังนี้:

1. โหลดเคอร์เนล

- BIOS โหลดเคอร์เนลจากฮาร์ดดิสก์หรืออุปกรณ์อื่นๆ

- เคอร์เนลจะเริ่มทำงานในโหมดพิเศษเรียกว่า "protected mode"

- เคอร์เนลจะตั้งค่า stack และ heap ของตัวเอง

2. ตรวจสอบฮาร์ดแวร์

- เคอร์เนลจะตรวจสอบและระบุฮาร์ดแวร์ทั้งหมดที่มีในระบบ

- ตรวจสอบ CPU, RAM, อุปกรณ์ต่อพ่วง ฯลฯ

- เก็บข้อมูลเกี่ยวกับฮาร์ดแวร์ในโครงสร้างข้อมูลต่างๆ

3. ตั้งค่าระบบ

- เคอร์เนลจะตั้งค่าระบบต่างๆ เช่น หน่วยความจำ การจัดการกระบวนการ และระบบไฟล์

- ตั้งค่าตารางเวลาสำหรับการทำงานของ CPU

- กำหนดค่าหน่วยความจำเสมือน

- เริ่มต้นระบบไฟล์

4. เริ่มต้นอุปกรณ์

- เคอร์เนลจะโหลดไดรเวอร์อุปกรณ์

- เริ่มต้นอุปกรณ์ต่างๆ เช่น ฮาร์ดดิสก์, เครือข่าย, อุปกรณ์ต่อพ่วง ฯลฯ

- ตั้งค่า IRQ สำหรับอุปกรณ์ต่างๆ
  
5. เริ่มต้น init system

- เคอร์เนลจะเริ่ม init system

- init system รับผิดชอบในการเริ่มต้นบริการระบบและโปรแกรมอื่นๆ

- ผู้ใช้สามารถกำหนดค่า init system ได้
  
### ตำแหน่งของเคอร์เนล:

- ไฟล์เคอร์เนลโดยทั่วไปจะอยู่ในพาร์ติชัน `/boot` ในระบบ Linux
  
---
### ขั้นตอนของ Kernel stage มีดังนี้:

1.โหลดเคอร์เนล: ไบออส (BIOS) โหลดไฟล์เคอร์เนลจากฮาร์ดดิสก์หรืออุปกรณ์จัดเก็บข้อมูลอื่นๆ เข้าสู่หน่วยความจำ

2.ตรวจสอบและเตรียมฮาร์ดแวร์: เคอร์เนลจะตรวจสอบและระบุคอมโพเนนต์ฮาร์ดแวร์ทั้งหมดในระบบ รวมถึง CPU, RAM, ฮาร์ดดิสก์, อุปกรณ์เครือข่าย และอุปกรณ์ต่อพ่วงอื่นๆ จากนั้นจึงเตรียมอุปกรณ์เหล่านั้นให้พร้อมใช้งาน

3.ตั้งค่าระบบ: เคอร์เนลจะกำหนดค่าตัวแปรระบบสำคัญต่างๆ เช่น ตารางหน่วยความจำ, การจัดการกระบวนการ, และระบบไฟล์

4.โหลดไดรเวอร์อุปกรณ์: เคอร์เนลจะโหลดไดรเวอร์ที่เหมาะสมสำหรับอุปกรณ์ฮาร์ดแวร์ที่ตรวจพบ ไดรเวอร์เหล่านี้ช่วยให้เคอร์เนลสามารถโต้ตอบกับอุปกรณ์เหล่านั้นได้

5.ติดตั้งระบบไฟล์ราก: เคอร์เนลจะติดตั้งระบบไฟล์ราก ซึ่งเป็นตำแหน่งเริ่มต้นที่เก็บไฟล์ระบบปฏิบัติการที่จำเป็น

6.เริ่มต้น init process: สุดท้าย เคอร์เนลจะเริ่มต้นกระบวนการพิเศษที่ชื่อว่า init (PID 1) กระบวนการนี้รับผิดชอบในการเริ่มต้นบริการระบบและโปรแกรมอื่นๆ ที่จำเป็นในการใช้งานคอมพิวเตอร์ตามปกติ

---
### Command ที่เกี่ยวข้องกับ Kernel stage 

Command:
`dmesg`

- สามารถใช้หลังจากบูตระบบ เพื่อดูข้อความต่างๆที่เคอร์เนลส่งออก ที่เคอร์เนลสร้างขึ้นระหว่างการบูต โดยข้อความเหล่านี้จะถูกเก็บไว้ในไฟล์ `/var/log/dmesg` ซึ่งจะถูกเขียนทับทุกครั้งที่มีการบูตระบบ 

Options/Arguments:

- `c` ล้างข้อความทั้งหมดใน buffer

- `-T`: แสดง timestamp ของข้อความ

- `-l`: แสดงข้อความทั้งหมด (ไม่จำกัดจำนวน)

- `-n`: แสดงหมายเลขบรรทัด

- `p` แสดงชื่อ PID ของกระบวนการที่ส่งข้อความ

- `-s`: แสดงข้อความสั้นๆ

- `-t`: แสดง timestamp 

- `-w`: รอให้มีข้อความใหม่ปรากฏ

ตัวอย่าง:

 - แสดงเฉพาะข้อความที่เกี่ยวข้องกับข้อผิดพลาด:

```
dmesg | grep -i "error"
```

> [!CAUTION]
> การดึงข้อมูล dmesg อยู่ตลอดเวลาอาจทำให้ระบบทำงานช้าลง
>
> ผู้ใช้ควรหยุดการดึงข้อมูล dmesg เมื่อไม่ใช้งาน

<a id="Initstage"></a>
# :round_pushpin: Init stage

Init stage คือ กระบวนการเริ่มต้นระบบปฏิบัติการLinux  ทำหน้าที่ควบคุมกระบวนการเริ่มต้นระบบปฏิบัติการ ประกอบด้วยชุดของสคริปต์และบริการที่รันตามลำดับเพื่อเตรียมระบบให้พร้อมใช้งานสำหรับผู้ใช้  

> [!NOTE]
> ในระบบปฏิบัติการ Linux บางรุ่น ชื่อของ init อาจถูกแทนที่ด้วย Upstart หรือ Systemd แม้ว่ายังคงใช้ไฟล์ชื่อ init และ กระบวนการ init เพื่อรักษาความเข้ากันได้กับโปรแกรมเก่าๆ

#### กรณีใช้ Upstart:

- ไฟล์สคริปต์ในโฟลเดอร์ `/etc/init` จะถูกใช้เพื่อดำเนินกระบวนการเริ่มต้นระบบจนเสร็จสิ้นสมบูรณ์

#### กรณีใช้ ystemd:

- ไฟล์ต่างๆ ในโฟลเดอร์ `/etc/systemd` จะถูกใช้เพื่อเริ่มต้นและรันระบบ

#### ไม่ว่าจะ Upstart หรือ Systemd:

- กระบวนการชื่อ init (/sbin/init) ยังคงทำงานอยู่เบื้องหลังเพื่อรักษาความเข้ากันได้กับโปรแกรมเก่าๆ

---
### initramfs 
initramfs (initial RAM filesystem) คือระบบไฟล์รูทเบื้องต้นที่ระบบ Linux มักจะเข้าถึงได้ คิดว่ามันเป็นเหมือนระบบไฟล์ "สตาร์ทเตอร์" ชั่วคราว:

- initramfsมีไฟล์และไดร์เวอร์ที่จำเป็นสำหรับการเริ่มต้นระบบไฟล์รูทจริงและดำเนินการเริ่มต้นระบบ
  
- initramfs เป็น `cpio` :
  
   - เนื้อหาถูกอ่านโดยเคอร์เนล
     
   - จากนั้นโหลดลงใน RAM disk โดยเคอร์เนลเพื่อเข้าถึง
     
- หลังจากอ่าน:
  
   - เคอร์เนลจะเรียกใช้สคริปต์ init ที่รวมอยู่ใน root / ของ initramfs RAM disk
 
### ข้อดีของการใส่ไดร์เวอร์ใน initramfs แทนการคอมไพล์เข้ากับเคอร์เนลคือ:

- เมื่อเคอร์เนลบูตเสร็จสมบูรณ์และติดตั้งระบบไฟล์รูทจริงแล้ว หน่วยความจำที่จัดสรรให้กับ initial RAM disk สามารถเป็นอิสระได้
  
- initramfs สร้างขึ้นครั้งแรกด้วย `mkinitramfs` หรืออัปเดตด้วย `update-initramfs`
  
---
### หลักการทำงาน:

1.การเริ่มต้น:

- เมื่อเปิดเครื่อง BIOS จะโหลด bootloader

- Bootloader โหลดเคอร์เนล Linux

- เคอร์เนลเริ่มต้น init process

- Init process อ่านค่าจากไฟล์ `/etc/inittab`

- Init process รันสคริปต์สำหรับ init stage เริ่มต้น
  
2.การเปลี่ยน init stage:

- ผู้ใช้สามารถเปลี่ยน init stage ได้โดยใช้คำสั่ง `init`

- ตัวอย่าง: `init 3` เริ่มต้นระบบใน multi-user mode
  
3.การปิดระบบ:

- ผู้ใช้สามารถปิดระบบได้โดยใช้คำสั่ง `shutdown`

- Shutdown process เรียกใช้สคริปต์ shutdown

- สคริปต์ shutdown ปิดบริการระบบอย่างปลอดภัย

- สุดท้าย ปิดเครื่องหรือ halt ระบบ
  
---
### การเรียกใช้งานและผลลัพธ์ที่ได้

ผู้ใช้สามารถเรียกใช้งาน init stage ได้โดยใช้คำสั่ง `init`

- รูปแบบ: `init <level>`

- `<level>` คือหมายเลขของ init stage (0-6)

#### คำสั่งที่เกี่ยวข้องกับ Init stage ใน Linux
1. init:

- Options:

    - `n` : ไม่เปลี่ยน init stage จริง แสดงผลลัพธ์ที่จะเกิดขึ้น
  
    - `q` : เงียบ ไม่แสดงข้อความใด ๆ
  
    - `s` : shutdown
  
    - `t` : seconds รอ seconds วินาทีก่อน shutdown
      
- Arguments:

    -`<level>` : ระดับ init stage (0-6)
  
ตัวอย่าง:

- `init -n 3` : แสดงผลลัพธ์ที่จะเกิดขึ้นหากเปลี่ยน init stage ไปที่ 3

- `init -q 0` : ปิดเครื่องเงียบ ๆ

- `init -s` : shutdown

- `init -t 60 0` : รอ 60 วินาทีก่อน shutdown

2. shutdown:

- Options:

    - `-h` : shutdown
  
    - `-r` : reboot
  
    - `-c` : ยกเลิก shutdown
  
    - `-t` : seconds รอ seconds วินาทีก่อน shutdown
  
- Arguments:

    -`<message>` : ข้อความแจ้งเตือนผู้ใช้ก่อน shutdown
  
ตัวอย่าง:

```
shutdown -c: ยกเลิก shutdown
```

3. systemctl:

- Options:

    - `-h` : แสดง help

    - `-l` : แสดงรายชื่อ services

    - `-i` : แสดง information เกี่ยวกับ service

    - `-s` : shutdown

    - `-r` : reboot

- Arguments:

    - `<command>` : คำสั่ง systemctl
  
    - `<service>` : ชื่อ service
  
ตัวอย่าง:

```
  systemctl -l: แสดงรายชื่อ services
```

> [!CAUTION]
> การเปลี่ยน init stage โดยไม่ได้ตั้งใจอาจทำให้ระบบหยุดทำงาน
> 
> การปิดระบบโดยไม่ปิดบริการอย่างปลอดภัยอาจทำให้ข้อมูลเสียหาย
> 
> การใช้คำสั่ง init กับ options หรือ arguments ที่ไม่ถูกต้องอาจทำให้เกิดผลลัพธ์ที่ไม่คาดคิด


## reference
- [https://linuxhint.com/schedule_linux_task/](https://wiki.gentoo.org/wiki/Linux_firmware)

- https://docs.aic-eec.com/computer-operation-system/zero-to-linux-hero/anatomy-of-embedded-linux/bootloader

- https://www.kernel.org/doc/html/latest/process/index.html

- https://www.kernel.org/doc/html/latest/admin-guide/init.html
